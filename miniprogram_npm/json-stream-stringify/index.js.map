{"version":3,"sources":["umd.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('stream')) :\n  typeof define === 'function' && define.amd ? define(['stream'], factory) :\n  (global.jsonStreamStringify = factory(global.stream));\n}(this, (function (stream) { \n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  var rxEscapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; // table of character substitutions\n\n  var meta = {\n    '\\b': '\\\\b',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\f': '\\\\f',\n    '\\r': '\\\\r',\n    '\"': '\\\\\"',\n    '\\\\': '\\\\\\\\'\n  };\n\n  function isReadableStream(value) {\n    return typeof value.read === 'function' && typeof value.once === 'function' && typeof value.removeListener === 'function' && _typeof(value._readableState) === 'object';\n  }\n\n  function getType(value) {\n    if (!value) return 'Primitive';\n    if (typeof value.then === 'function') return 'Promise';\n    if (isReadableStream(value)) return \"Readable\".concat(value._readableState.objectMode ? 'Object' : 'String');\n    if (Array.isArray(value)) return 'Array';\n    if (_typeof(value) === 'object' || value instanceof Object) return 'Object';\n    return 'Primitive';\n  }\n\n  var stackItemEnd = {\n    Array: ']',\n    Object: '}',\n    ReadableString: '\"',\n    ReadableObject: ']'\n  };\n  var stackItemOpen = {\n    Array: '[',\n    Object: '{',\n    ReadableString: '\"',\n    ReadableObject: '['\n  };\n\n  function escapeString(string) {\n    // Modified code, original code by Douglas Crockford\n    // Original: https://github.com/douglascrockford/JSON-js/blob/master/json2.js\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    return string.replace(rxEscapable, function (a) {\n      var c = meta[a];\n      return typeof c === 'string' ? c : \"\\\\u\".concat(a.charCodeAt(0).toString(16).padStart(4, '0'));\n    });\n  }\n\n  function quoteString(string) {\n    return \"\\\"\".concat(escapeString(string), \"\\\"\");\n  }\n\n  function readAsPromised(stream$$1, size) {\n    var value = stream$$1.read(size);\n\n    if (value === null) {\n      return new Promise(function (resolve, reject) {\n        var endListener = function endListener() {\n          return resolve(null);\n        };\n\n        stream$$1.once('end', endListener);\n        stream$$1.once('error', reject);\n        stream$$1.once('readable', function () {\n          stream$$1.removeListener('end', endListener);\n          stream$$1.removeListener('error', reject);\n          resolve(stream$$1.read());\n        });\n      });\n    }\n\n    return Promise.resolve(value);\n  }\n\n  function recursiveResolve(promise) {\n    return promise.then(function (res) {\n      var resType = getType(res);\n      return resType === 'Promise' ? recursiveResolve(res) : res;\n    });\n  }\n\n  var JsonStreamStringify =\n  /*#__PURE__*/\n  function (_Readable) {\n    _inherits(JsonStreamStringify, _Readable);\n\n    function JsonStreamStringify(value, replacer, spaces, cycle) {\n      var _this;\n\n      _classCallCheck(this, JsonStreamStringify);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(JsonStreamStringify).call(this, {}));\n      var gap;\n\n      var spaceType = _typeof(spaces);\n\n      if (spaceType === 'string' || spaceType === 'number') {\n        gap = Number.isFinite(spaces) ? ' '.repeat(spaces) : spaces;\n      }\n\n      Object.assign(_assertThisInitialized(_assertThisInitialized(_this)), {\n        visited: cycle ? new WeakMap() : new WeakSet(),\n        cycle: cycle,\n        stack: [],\n        replacerFunction: replacer instanceof Function && replacer,\n        replacerArray: Array.isArray(replacer) && replacer,\n        gap: gap,\n        depth: 0\n      });\n\n      _this.addToStack(value);\n\n      return _this;\n    }\n\n    _createClass(JsonStreamStringify, [{\n      key: \"cycler\",\n      value: function cycler(key, value) {\n        var existingPath = this.visited.get(value);\n\n        if (existingPath) {\n          return {\n            $ref: existingPath\n          };\n        }\n\n        var path = this.path();\n        if (key !== undefined) path.push(key);\n        path = path.map(function (v) {\n          return \"[\".concat(Number.isInteger(v) ? v : quoteString(v), \"]\");\n        });\n        this.visited.set(value, path.length ? \"$\".concat(path.join('')) : '$');\n        return value;\n      }\n    }, {\n      key: \"addToStack\",\n      value: function addToStack(value, key, index, parent) {\n        var _this2 = this;\n\n        var realValue = value;\n\n        if (this.replacerFunction) {\n          realValue = this.replacerFunction(key || index, realValue, this);\n        } // ORDER?\n\n\n        if (realValue && realValue.toJSON instanceof Function) {\n          realValue = realValue.toJSON();\n        }\n\n        if (realValue instanceof Function || _typeof(value) === 'symbol') {\n          realValue = undefined;\n        }\n\n        if (key !== undefined && this.replacerArray) {\n          if (!this.replacerArray.includes(key)) {\n            realValue = undefined;\n          }\n        }\n\n        var type = getType(realValue);\n\n        if ((parent && parent.type === 'Array' ? true : realValue !== undefined) && type !== 'Promise') {\n          if (parent && !parent.first) {\n            this._push(',');\n          }\n          /* eslint-disable-next-line no-param-reassign */\n\n\n          if (parent) parent.first = false;\n        }\n\n        if (realValue !== undefined && type !== 'Promise' && key) {\n          if (this.gap) {\n            this._push(\"\\n\".concat(this.gap.repeat(this.depth), \"\\\"\").concat(escapeString(key), \"\\\": \"));\n          } else {\n            this._push(\"\\\"\".concat(escapeString(key), \"\\\":\"));\n          }\n        }\n\n        if (type !== 'Primitive') {\n          if (this.cycle) {\n            // run cycler\n            realValue = this.cycler(key || index, realValue);\n            type = getType(realValue);\n          } else {\n            // check for circular structure\n            if (this.visited.has(realValue)) {\n              throw Object.assign(new Error('Converting circular structure to JSON'), {\n                realValue: realValue,\n                key: key || index\n              });\n            }\n\n            this.visited.add(realValue);\n          }\n        }\n\n        if (!key && index > -1 && this.depth && this.gap) this._push(\"\\n\".concat(this.gap.repeat(this.depth)));\n        var open = stackItemOpen[type];\n        if (open) this._push(open);\n        var obj = {\n          key: key,\n          index: index,\n          type: type,\n          value: realValue,\n          parent: parent,\n          first: true\n        };\n\n        if (type === 'Object') {\n          this.depth += 1;\n          obj.unread = Object.keys(realValue);\n          obj.isEmpty = !obj.unread.length;\n        } else if (type === 'Array') {\n          this.depth += 1;\n          obj.unread = realValue.length;\n          obj.arrayLength = obj.unread;\n          obj.isEmpty = !obj.unread;\n        } else if (type.startsWith('Readable')) {\n          this.depth += 1;\n\n          if (realValue._readableState.ended) {\n            this.emit('error', new Error('Readable Stream has ended before it was serialized. All stream data have been lost'), realValue, key || index);\n          } else if (realValue._readableState.flowing) {\n            realValue.pause();\n            this.emit('error', new Error('Readable Stream is in flowing mode, data may have been lost. Trying to pause stream.'), realValue, key || index);\n          }\n\n          obj.readCount = 0;\n          realValue.once('end', function () {\n            obj.end = true;\n\n            _this2.__read();\n          });\n          realValue.once('error', function (err) {\n            _this2.error = true;\n\n            _this2.emit('error', err);\n          });\n        }\n\n        this.stack.unshift(obj);\n        return obj;\n      }\n    }, {\n      key: \"removeFromStack\",\n      value: function removeFromStack(item) {\n        var type = item.type;\n        var isObject = type === 'Object' || type === 'Array' || type.startsWith('Readable');\n\n        if (type !== 'Primitive') {\n          if (!this.cycle) {\n            this.visited.delete(item.value);\n          }\n\n          if (isObject) {\n            this.depth -= 1;\n          }\n        }\n\n        var end = stackItemEnd[type];\n        if (isObject && !item.isEmpty && this.gap) this._push(\"\\n\".concat(this.gap.repeat(this.depth)));\n        if (end) this._push(end);\n        var stackIndex = this.stack.indexOf(item);\n        this.stack.splice(stackIndex, 1);\n      }\n    }, {\n      key: \"_push\",\n      value: function _push(data) {\n        this.pushCalled = true;\n        this.push(data);\n      }\n    }, {\n      key: \"processReadableObject\",\n      value: function processReadableObject(current, size) {\n        var _this3 = this;\n\n        if (current.end) {\n          this.removeFromStack(current);\n          return undefined;\n        }\n\n        return readAsPromised(current.value, size).then(function (value) {\n          if (value !== null) {\n            if (!current.first) {\n              _this3._push(',');\n            }\n            /* eslint-disable no-param-reassign */\n\n\n            current.first = false;\n\n            _this3.addToStack(value, undefined, current.readCount);\n\n            current.readCount += 1;\n            /* eslint-enable no-param-reassign */\n          }\n        });\n      }\n    }, {\n      key: \"processObject\",\n      value: function processObject(current) {\n        // when no keys left, remove obj from stack\n        if (!current.unread.length) {\n          this.removeFromStack(current);\n          return;\n        }\n\n        var key = current.unread.shift();\n        var value = current.value[key];\n        this.addToStack(value, key, undefined, current);\n      }\n    }, {\n      key: \"processArray\",\n      value: function processArray(current) {\n        var key = current.unread;\n\n        if (!key) {\n          this.removeFromStack(current);\n          return;\n        }\n\n        var index = current.arrayLength - key;\n        var value = current.value[index];\n        /* eslint-disable-next-line no-param-reassign */\n\n        current.unread -= 1;\n        this.addToStack(value, undefined, index, current);\n      }\n    }, {\n      key: \"processPrimitive\",\n      value: function processPrimitive(current) {\n        if (current.value !== undefined) {\n          var type = _typeof(current.value);\n\n          var value;\n\n          switch (type) {\n            case 'string':\n              value = quoteString(current.value);\n              break;\n\n            case 'number':\n              value = Number.isFinite(current.value) ? String(current.value) : 'null';\n              break;\n\n            case 'boolean':\n            case 'null':\n              value = String(current.value);\n              break;\n\n            case 'object':\n              if (!current.value) {\n                value = 'null';\n                break;\n              }\n\n            /* eslint-disable-next-line no-fallthrough */\n\n            default:\n              // This should never happen, I can't imagine a situation where this executes.\n              // If you find a way, please open a ticket or PR\n              throw Object.assign(new Error(\"Unknown type \\\"\".concat(type, \"\\\". Please file an issue!\")), {\n                value: current.value\n              });\n          }\n\n          this._push(value);\n        } else if (this.stack[1] && (this.stack[1].type === 'Array' || this.stack[1].type === 'ReadableObject')) {\n          this._push('null');\n        } else {\n          /* eslint-disable-next-line no-param-reassign */\n          current.addSeparatorAfterEnd = false;\n        }\n\n        this.removeFromStack(current);\n      }\n    }, {\n      key: \"processReadableString\",\n      value: function processReadableString(current, size) {\n        var _this4 = this;\n\n        if (current.end) {\n          this.removeFromStack(current);\n          return undefined;\n        }\n\n        return readAsPromised(current.value, size).then(function (value) {\n          if (value) _this4._push(escapeString(value.toString()));\n        });\n      }\n    }, {\n      key: \"processPromise\",\n      value: function processPromise(current) {\n        var _this5 = this;\n\n        return recursiveResolve(current.value).then(function (value) {\n          _this5.removeFromStack(current);\n\n          _this5.addToStack(value, current.key, current.index, current.parent);\n        });\n      }\n    }, {\n      key: \"processStackTopItem\",\n      value: function processStackTopItem(size) {\n        var _this6 = this;\n\n        var current = this.stack[0];\n        if (!current || this.error) return Promise.resolve();\n        var out;\n\n        try {\n          out = this[\"process\".concat(current.type)](current, size);\n        } catch (err) {\n          return Promise.reject(err);\n        }\n\n        return Promise.resolve(out).then(function () {\n          if (_this6.stack.length === 0) {\n            _this6.end = true;\n\n            _this6._push(null);\n          }\n        });\n      }\n    }, {\n      key: \"__read\",\n      value: function __read(size) {\n        var _this7 = this;\n\n        if (this.isRunning || this.error) {\n          this.readMore = true;\n          return undefined;\n        }\n\n        this.isRunning = true; // we must continue to read while push has not been called\n\n        this.readMore = false;\n        return this.processStackTopItem(size).then(function () {\n          var readAgain = !_this7.end && !_this7.error && (_this7.readMore || !_this7.pushCalled);\n\n          if (readAgain) {\n            setImmediate(function () {\n              _this7.isRunning = false;\n\n              _this7.__read();\n            });\n          } else {\n            _this7.isRunning = false;\n          }\n        }).catch(function (err) {\n          _this7.error = true;\n\n          _this7.emit('error', err);\n        });\n      }\n    }, {\n      key: \"_read\",\n      value: function _read(size) {\n        this.pushCalled = false;\n\n        this.__read(size);\n      }\n    }, {\n      key: \"path\",\n      value: function path() {\n        return this.stack.map(function (_ref) {\n          var key = _ref.key,\n              index = _ref.index;\n          return key || index;\n        }).filter(function (v) {\n          return v || v > -1;\n        }).reverse();\n      }\n    }]);\n\n    return JsonStreamStringify;\n  }(stream.Readable);\n\n  return JsonStreamStringify;\n\n})));\n//# sourceMappingURL=umd.js.map\n"]}
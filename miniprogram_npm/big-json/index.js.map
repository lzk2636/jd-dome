{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n// core modules\nconst stream = require('stream');\nconst util = require('util');\n\n// external modules\nconst assert = require('assert-plus');\nconst intoStream = require('into-stream');\nconst JSONStream = require('JSONStream');\nconst through2 = require('through2');\nconst once = require('once').strict;\nconst JsonStreamStringify = require('json-stream-stringify');\n\n// promisified implementations of callback APIs.\nconst _parsePromisified = util.promisify(_parse);\nconst _stringifyPromisified = util.promisify(_stringify);\n\n/**\n * Create a JSON.parse that uses a stream interface. The underlying\n * implementation is handled by JSONStream. This is merely a thin wrapper for\n * convenience that handles the reconstruction/accumulation of each\n * individually parsed field.\n *\n * The advantage of this approach is that by also using a streams interface,\n * any JSON parsing or stringification of large objects won't block the CPU.\n * @public\n * @function createParseStream\n * @return {Stream}\n */\nfunction createParseStream() {\n    // when the parse stream gets chunks of data, it is an object with key/val\n    // fields. accumulate the parsed fields.\n    const accumulator = {};\n    const parseStream = JSONStream.parse('$*');\n    const wrapperStream = through2.obj(\n        function write(chunk, enc, cb) {\n            parseStream.write(chunk);\n            return cb();\n        },\n        function flush(cb) {\n            parseStream.on('end', function() {\n                return cb(null, accumulator);\n            });\n            parseStream.end();\n        }\n    );\n\n    // for each chunk parsed, add it to the accumulator\n    parseStream.on('data', function(chunk) {\n        accumulator[chunk.key] = chunk.value;\n    });\n\n    // make sure error is forwarded on to wrapper stream.\n    parseStream.on('error', function(err) {\n        wrapperStream.emit('error', err);\n    });\n\n    return wrapperStream;\n}\n\n/**\n * create a JSON.stringify readable stream.\n * @public\n * @param {Object} opts an options object\n * @param {Object} opts.body the JS object to JSON.stringify\n * @function createStringifyStream\n * @return {Stream}\n */\nfunction createStringifyStream(opts) {\n    assert.object(opts, 'opts');\n    assert.ok(\n        Array.isArray(opts.body) || typeof opts.body === 'object',\n        'opts.body must be an array or object'\n    );\n\n    return new JsonStreamStringify(opts.body, null, null, false);\n}\n\n/**\n * stream based JSON.parse. async function signature to abstract over streams.\n * @public\n * @param {Object} opts options to pass to parse stream\n * @param {String} opts.body string to parse\n * @param {Function} callback a callback function\n * @return {Object} the parsed JSON object\n */\nfunction _parse(opts, callback) {\n    assert.object(opts, 'opts');\n    assert.string(opts.body, 'opts.body');\n    assert.func(callback, 'callback');\n\n    const sourceStream = intoStream(opts.body);\n    const parseStream = createParseStream();\n    const cb = once(callback);\n\n    parseStream.on('data', function(data) {\n        return cb(null, data);\n    });\n\n    parseStream.on('error', function(err) {\n        return cb(err);\n    });\n\n    sourceStream.pipe(parseStream);\n}\n\n/**\n * stream based JSON.parse. async function signature to abstract over streams.\n * variadic arguments to support both promise and callback based usage.\n * @public\n * @function parse\n * @param {Object} opts options to pass to parse stream\n * @param {String} opts.body string to parse\n * @param {Function} [callback] a callback function. if empty, returns a\n * promise.\n * @return {Object} the parsed JSON object\n */\nfunction parse(opts, callback) {\n    // if more than one argument was passed, assume it's a callback based usage.\n    if (arguments.length > 1) {\n        return _parse(opts, callback);\n    }\n\n    // otherwise, caller expects a promise.\n    return _parsePromisified(opts);\n}\n\n/**\n * stream based JSON.stringify. async function signature to abstract over\n * streams.\n * @private\n * @param {Object} opts options to pass to stringify stream\n * @param {Function} callback a callback function\n * @return {Object} the parsed JSON object\n */\nfunction _stringify(opts, callback) {\n    assert.object(opts, 'opts');\n    assert.func(callback, 'callback');\n\n    let stringified = '';\n    const stringifyStream = createStringifyStream(opts);\n    const passthroughStream = new stream.PassThrough();\n    const cb = once(callback);\n\n    // setup the passthrough stream as a sink\n    passthroughStream.on('data', function(chunk) {\n        stringified += chunk;\n    });\n\n    passthroughStream.on('end', function() {\n        return cb(null, stringified);\n    });\n\n    // don't know what errors stringify stream may emit, but pass them back\n    // up.\n    stringifyStream.on('error', function(err) {\n        return cb(err);\n    });\n\n    stringifyStream.pipe(passthroughStream);\n}\n\n/**\n * stream based JSON.stringify. async function signature to abstract over\n * streams. variadic arguments to support both promise and callback based usage.\n * @public\n * @function stringify\n * @param {Object} opts options to pass to stringify stream\n * @param {Function} [callback] a callback function. if empty, returns a\n * promise.\n * @return {Object} the parsed JSON object\n */\nfunction stringify(opts, callback) {\n    // if more than one argument was passed, assume it's a callback based usage.\n    if (arguments.length > 1) {\n        return _stringify(opts, callback);\n    }\n\n    // otherwise, caller expects a promise.\n    return _stringifyPromisified(opts);\n}\n\nmodule.exports = {\n    createParseStream,\n    createStringifyStream,\n    parse,\n    stringify\n};\n"]}